; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	d:\source\blog posts\libraries\c\TestCharFrequncy.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG3971	DB	0aH, 'Printing frequency list:', 00H
	ORG $+2
$SG3976	DB	0aH, ' %c - %i.', 00H
	ORG $+1
$SG3977	DB	0aH, 00H
	ORG $+2
$SG3984	DB	0aH, 'Printing frequency map:', 00H
	ORG $+3
$SG3989	DB	0aH, 00H
	ORG $+2
$SG3993	DB	'%c', 00H
	ORG $+1
$SG3994	DB	0aH, 00H
	ORG $+2
$SG4052	DB	'Abc', 00H
$SG4053	DB	0aH, 'Testing in ''Abc''.', 0aH, 00H
$SG4054	DB	0aH, 'Frequency of ''A'': %i', 0aH, 00H
	ORG $+1
$SG4055	DB	0aH, 'Frequency of ''b'': %i', 0aH, 00H
	ORG $+1
$SG4056	DB	0aH, 'Frequency of ''c'': %i', 0aH, 00H
	ORG $+1
$SG4057	DB	0aH, 'Frequency of ''d'': %i', 0aH, 00H
	ORG $+1
$SG4058	DB	'AbcAAbd', 00H
$SG4059	DB	0aH, 'Testing in ''AbcAAbd''.', 0aH, 00H
$SG4060	DB	0aH, 'Frequency of ''A'': %i', 0aH, 00H
	ORG $+1
$SG4061	DB	0aH, 'Frequency of ''b'': %i', 0aH, 00H
	ORG $+1
$SG4062	DB	0aH, 'Frequency of ''c'': %i', 0aH, 00H
	ORG $+1
$SG4063	DB	0aH, 'Frequency of ''d'': %i', 0aH, 00H
_DATA	ENDS
PUBLIC	_Contains
; Function compile flags: /Odtp
; File d:\source\blog posts\libraries\c\charfrequency.c
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_ch$ = 8						; size = 1
_cf$ = 12						; size = 4
_Contains PROC

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 17   : 	struct CharIntNode * curr = cf->first;

  00004	8b 45 0c	 mov	 eax, DWORD PTR _cf$[ebp]
  00007	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000a	89 4d fc	 mov	 DWORD PTR _curr$[ebp], ecx

; 18   : 	if(curr == NULL){

  0000d	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  00011	75 04		 jne	 SHORT $LN3@Contains

; 19   : 		return false;

  00013	33 c0		 xor	 eax, eax
  00015	eb 28		 jmp	 SHORT $LN5@Contains
$LN3@Contains:

; 20   : 	}
; 21   : 	while(curr != NULL){

  00017	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  0001b	74 20		 je	 SHORT $LN2@Contains

; 22   : 		if(curr -> ch == ch)

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _curr$[ebp]
  00020	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00023	0f be 4d 08	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00027	3b c1		 cmp	 eax, ecx
  00029	75 07		 jne	 SHORT $LN1@Contains

; 23   : 			return true;

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	eb 0d		 jmp	 SHORT $LN5@Contains
$LN1@Contains:

; 24   : 		curr = curr -> next;

  00032	8b 55 fc	 mov	 edx, DWORD PTR _curr$[ebp]
  00035	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00038	89 45 fc	 mov	 DWORD PTR _curr$[ebp], eax

; 25   : 	}

  0003b	eb da		 jmp	 SHORT $LN3@Contains
$LN2@Contains:

; 26   : 	return false;

  0003d	33 c0		 xor	 eax, eax
$LN5@Contains:

; 27   : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_Contains ENDP
_TEXT	ENDS
PUBLIC	_GetFrequency
; Function compile flags: /Odtp
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_ch$ = 8						; size = 1
_cf$ = 12						; size = 4
_GetFrequency PROC

; 30   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	51		 push	 ecx

; 31   : 	struct CharIntNode * curr = cf->first;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _cf$[ebp]
  00057	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0005a	89 4d fc	 mov	 DWORD PTR _curr$[ebp], ecx

; 32   : 	if(curr == NULL){

  0005d	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  00061	75 04		 jne	 SHORT $LN3@GetFrequen

; 33   : 		return 0;

  00063	33 c0		 xor	 eax, eax
  00065	eb 29		 jmp	 SHORT $LN5@GetFrequen
$LN3@GetFrequen:

; 34   : 	} 
; 35   : 	while(curr != NULL){

  00067	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  0006b	74 21		 je	 SHORT $LN2@GetFrequen

; 36   : 		if(curr -> ch == ch)

  0006d	8b 55 fc	 mov	 edx, DWORD PTR _curr$[ebp]
  00070	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00073	0f be 4d 08	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00077	3b c1		 cmp	 eax, ecx
  00079	75 08		 jne	 SHORT $LN1@GetFrequen

; 37   : 			return curr -> f;

  0007b	8b 55 fc	 mov	 edx, DWORD PTR _curr$[ebp]
  0007e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00081	eb 0d		 jmp	 SHORT $LN5@GetFrequen
$LN1@GetFrequen:

; 38   : 		curr = curr -> next;

  00083	8b 45 fc	 mov	 eax, DWORD PTR _curr$[ebp]
  00086	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00089	89 4d fc	 mov	 DWORD PTR _curr$[ebp], ecx

; 39   : 	}

  0008c	eb d9		 jmp	 SHORT $LN3@GetFrequen
$LN2@GetFrequen:

; 40   : 	return 0;

  0008e	33 c0		 xor	 eax, eax
$LN5@GetFrequen:

; 41   : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_GetFrequency ENDP
_TEXT	ENDS
PUBLIC	_PrintFrequencyList
EXTRN	_printf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_cf$ = 8						; size = 4
_PrintFrequencyList PROC

; 44   : {

  000a0	55		 push	 ebp
  000a1	8b ec		 mov	 ebp, esp
  000a3	51		 push	 ecx

; 45   : 	struct CharIntNode * curr = cf->first;

  000a4	8b 45 08	 mov	 eax, DWORD PTR _cf$[ebp]
  000a7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000aa	89 4d fc	 mov	 DWORD PTR _curr$[ebp], ecx

; 46   : 	printf("\nPrinting frequency list:");

  000ad	68 00 00 00 00	 push	 OFFSET $SG3971
  000b2	e8 00 00 00 00	 call	 _printf
  000b7	83 c4 04	 add	 esp, 4
$LN2@PrintFrequ:

; 47   : 	while(curr != NULL){

  000ba	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  000be	74 26		 je	 SHORT $LN1@PrintFrequ

; 48   : 		printf("\n %c - %i.", curr->ch, curr->f);

  000c0	8b 55 fc	 mov	 edx, DWORD PTR _curr$[ebp]
  000c3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c6	50		 push	 eax
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _curr$[ebp]
  000ca	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000cd	52		 push	 edx
  000ce	68 00 00 00 00	 push	 OFFSET $SG3976
  000d3	e8 00 00 00 00	 call	 _printf
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 49   : 		curr = curr->next;

  000db	8b 45 fc	 mov	 eax, DWORD PTR _curr$[ebp]
  000de	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e1	89 4d fc	 mov	 DWORD PTR _curr$[ebp], ecx

; 50   : 	}

  000e4	eb d4		 jmp	 SHORT $LN2@PrintFrequ
$LN1@PrintFrequ:

; 51   : 	printf("\n");

  000e6	68 00 00 00 00	 push	 OFFSET $SG3977
  000eb	e8 00 00 00 00	 call	 _printf
  000f0	83 c4 04	 add	 esp, 4

; 52   : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_PrintFrequencyList ENDP
_TEXT	ENDS
PUBLIC	_PrintFrequencyMap
; Function compile flags: /Odtp
_TEXT	SEGMENT
_j$ = -12						; size = 4
_curr$ = -8						; size = 4
_i$ = -4						; size = 4
_cf$ = 8						; size = 4
_PrintFrequencyMap PROC

; 55   : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp
  00103	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 56   : 	struct CharIntNode * curr = cf->first;

  00106	8b 45 08	 mov	 eax, DWORD PTR _cf$[ebp]
  00109	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0010c	89 4d f8	 mov	 DWORD PTR _curr$[ebp], ecx

; 57   : 	int i = 0, j = 0;

  0010f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00116	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 58   : 	printf("\nPrinting frequency map:");

  0011d	68 00 00 00 00	 push	 OFFSET $SG3984
  00122	e8 00 00 00 00	 call	 _printf
  00127	83 c4 04	 add	 esp, 4
$LN5@PrintFrequ@2:

; 59   : 	while(curr != NULL){

  0012a	83 7d f8 00	 cmp	 DWORD PTR _curr$[ebp], 0
  0012e	74 4b		 je	 SHORT $LN4@PrintFrequ@2

; 60   : 		printf("\n");

  00130	68 00 00 00 00	 push	 OFFSET $SG3989
  00135	e8 00 00 00 00	 call	 _printf
  0013a	83 c4 04	 add	 esp, 4

; 61   : 		for(i = 0; i < curr->f; i++)

  0013d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00144	eb 09		 jmp	 SHORT $LN3@PrintFrequ@2
$LN2@PrintFrequ@2:
  00146	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00149	83 c2 01	 add	 edx, 1
  0014c	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN3@PrintFrequ@2:
  0014f	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  00152	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00155	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00158	7d 16		 jge	 SHORT $LN1@PrintFrequ@2

; 62   : 			printf("%c", curr->ch);

  0015a	8b 55 f8	 mov	 edx, DWORD PTR _curr$[ebp]
  0015d	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00160	50		 push	 eax
  00161	68 00 00 00 00	 push	 OFFSET $SG3993
  00166	e8 00 00 00 00	 call	 _printf
  0016b	83 c4 08	 add	 esp, 8
  0016e	eb d6		 jmp	 SHORT $LN2@PrintFrequ@2
$LN1@PrintFrequ@2:

; 63   : 		curr = curr->next;

  00170	8b 4d f8	 mov	 ecx, DWORD PTR _curr$[ebp]
  00173	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00176	89 55 f8	 mov	 DWORD PTR _curr$[ebp], edx

; 64   : 	}

  00179	eb af		 jmp	 SHORT $LN5@PrintFrequ@2
$LN4@PrintFrequ@2:

; 65   : 	printf("\n");

  0017b	68 00 00 00 00	 push	 OFFSET $SG3994
  00180	e8 00 00 00 00	 call	 _printf
  00185	83 c4 04	 add	 esp, 4

; 66   : }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
_PrintFrequencyMap ENDP
_TEXT	ENDS
PUBLIC	_BumpFrequency
PUBLIC	_Insert
PUBLIC	_Initialize
; Function compile flags: /Odtp
_TEXT	SEGMENT
_input$ = 8						; size = 4
_cf$ = 12						; size = 4
_Initialize PROC

; 69   : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp

; 70   : 	if(cf == NULL) return;

  00193	83 7d 0c 00	 cmp	 DWORD PTR _cf$[ebp], 0
  00197	75 02		 jne	 SHORT $LN6@Initialize
  00199	eb 6a		 jmp	 SHORT $LN7@Initialize
$LN6@Initialize:

; 71   : 	if(input == NULL) return;

  0019b	83 7d 08 00	 cmp	 DWORD PTR _input$[ebp], 0
  0019f	75 02		 jne	 SHORT $LN4@Initialize
  001a1	eb 62		 jmp	 SHORT $LN7@Initialize
$LN4@Initialize:

; 72   : 	while(*input){

  001a3	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  001a6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001a9	85 c9		 test	 ecx, ecx
  001ab	74 58		 je	 SHORT $LN7@Initialize

; 73   : 		if(!(cf->Contains(*input, cf))){

  001ad	8b 55 0c	 mov	 edx, DWORD PTR _cf$[ebp]
  001b0	52		 push	 edx
  001b1	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  001b4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001b7	51		 push	 ecx
  001b8	8b 55 0c	 mov	 edx, DWORD PTR _cf$[ebp]
  001bb	8b 02		 mov	 eax, DWORD PTR [edx]
  001bd	ff d0		 call	 eax
  001bf	83 c4 08	 add	 esp, 8
  001c2	85 c0		 test	 eax, eax
  001c4	75 1e		 jne	 SHORT $LN2@Initialize

; 74   : 			cf->first = Insert(*input, cf->first);

  001c6	8b 4d 0c	 mov	 ecx, DWORD PTR _cf$[ebp]
  001c9	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  001cc	52		 push	 edx
  001cd	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  001d0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001d3	51		 push	 ecx
  001d4	e8 00 00 00 00	 call	 _Insert
  001d9	83 c4 08	 add	 esp, 8
  001dc	8b 55 0c	 mov	 edx, DWORD PTR _cf$[ebp]
  001df	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 75   : 		}
; 76   : 		else {

  001e2	eb 16		 jmp	 SHORT $LN1@Initialize
$LN2@Initialize:

; 77   : 			BumpFrequency(*input, cf->first);

  001e4	8b 45 0c	 mov	 eax, DWORD PTR _cf$[ebp]
  001e7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001ea	51		 push	 ecx
  001eb	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  001ee	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _BumpFrequency
  001f7	83 c4 08	 add	 esp, 8
$LN1@Initialize:

; 78   : 		}
; 79   : 		input++;

  001fa	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  001fd	83 c1 01	 add	 ecx, 1
  00200	89 4d 08	 mov	 DWORD PTR _input$[ebp], ecx

; 80   : 	}

  00203	eb 9e		 jmp	 SHORT $LN4@Initialize
$LN7@Initialize:

; 81   : }

  00205	5d		 pop	 ebp
  00206	c3		 ret	 0
_Initialize ENDP
_TEXT	ENDS
PUBLIC	_CreateEmptyCharFrequency
PUBLIC	_SetupCharFrequency
; Function compile flags: /Odtp
_TEXT	SEGMENT
_cf$ = -4						; size = 4
_input$ = 8						; size = 4
_SetupCharFrequency PROC

; 84   : {

  00210	55		 push	 ebp
  00211	8b ec		 mov	 ebp, esp
  00213	51		 push	 ecx

; 85   : 	struct CharFrequency * cf = CreateEmptyCharFrequency();

  00214	e8 00 00 00 00	 call	 _CreateEmptyCharFrequency
  00219	89 45 fc	 mov	 DWORD PTR _cf$[ebp], eax

; 86   : 	cf->Contains = Contains;

  0021c	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  0021f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _Contains

; 87   : 	cf->GetFrequency = GetFrequency;

  00225	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00228	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET _GetFrequency

; 88   : 	cf->PrintFrequencyList = PrintFrequencyList;

  0022f	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  00232	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET _PrintFrequencyList

; 89   : 	cf->PrintFrequencyMap = PrintFrequencyMap;

  00239	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  0023c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET _PrintFrequencyMap

; 90   : 	cf->first = NULL;

  00243	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00246	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 91   : 	Initialize(input, cf);

  0024d	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  00250	52		 push	 edx
  00251	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 _Initialize
  0025a	83 c4 08	 add	 esp, 8

; 92   : 	return cf;

  0025d	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]

; 93   : }

  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
_SetupCharFrequency ENDP
_TEXT	ENDS
EXTRN	_malloc:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_cf$ = -4						; size = 4
_CreateEmptyCharFrequency PROC

; 96   : {

  00270	55		 push	 ebp
  00271	8b ec		 mov	 ebp, esp
  00273	51		 push	 ecx

; 97   : 	struct CharFrequency * cf = (struct CharFrequency *)malloc(sizeof(struct CharFrequency));

  00274	6a 14		 push	 20			; 00000014H
  00276	e8 00 00 00 00	 call	 _malloc
  0027b	83 c4 04	 add	 esp, 4
  0027e	89 45 fc	 mov	 DWORD PTR _cf$[ebp], eax

; 98   : 	if(cf == NULL){

  00281	83 7d fc 00	 cmp	 DWORD PTR _cf$[ebp], 0
  00285	75 0d		 jne	 SHORT $LN1@CreateEmpt

; 99   : 		cf = (struct CharFrequency *)malloc(sizeof(struct CharFrequency));

  00287	6a 14		 push	 20			; 00000014H
  00289	e8 00 00 00 00	 call	 _malloc
  0028e	83 c4 04	 add	 esp, 4
  00291	89 45 fc	 mov	 DWORD PTR _cf$[ebp], eax
$LN1@CreateEmpt:

; 100  : 	}
; 101  : 	return cf;

  00294	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]

; 102  : }

  00297	8b e5		 mov	 esp, ebp
  00299	5d		 pop	 ebp
  0029a	c3		 ret	 0
_CreateEmptyCharFrequency ENDP
_TEXT	ENDS
PUBLIC	_CreateEmptyCharIntNode
; Function compile flags: /Odtp
_TEXT	SEGMENT
_cin$ = -4						; size = 4
_CreateEmptyCharIntNode PROC

; 105  : {

  002a0	55		 push	 ebp
  002a1	8b ec		 mov	 ebp, esp
  002a3	51		 push	 ecx

; 106  : 	struct CharIntNode * cin = (struct CharIntNode *)malloc(sizeof(struct CharIntNode));

  002a4	6a 0c		 push	 12			; 0000000cH
  002a6	e8 00 00 00 00	 call	 _malloc
  002ab	83 c4 04	 add	 esp, 4
  002ae	89 45 fc	 mov	 DWORD PTR _cin$[ebp], eax

; 107  : 	if(cin == NULL){

  002b1	83 7d fc 00	 cmp	 DWORD PTR _cin$[ebp], 0
  002b5	75 0d		 jne	 SHORT $LN1@CreateEmpt@2

; 108  : 		cin = (struct CharIntNode *)malloc(sizeof(struct CharIntNode *));

  002b7	6a 04		 push	 4
  002b9	e8 00 00 00 00	 call	 _malloc
  002be	83 c4 04	 add	 esp, 4
  002c1	89 45 fc	 mov	 DWORD PTR _cin$[ebp], eax
$LN1@CreateEmpt@2:

; 109  : 	}
; 110  : 	return cin;

  002c4	8b 45 fc	 mov	 eax, DWORD PTR _cin$[ebp]

; 111  : }

  002c7	8b e5		 mov	 esp, ebp
  002c9	5d		 pop	 ebp
  002ca	c3		 ret	 0
_CreateEmptyCharIntNode ENDP
; Function compile flags: /Odtp
_tmp$ = -4						; size = 4
_ch$ = 8						; size = 1
_head$ = 12						; size = 4
_Insert	PROC

; 114  : {

  002d0	55		 push	 ebp
  002d1	8b ec		 mov	 ebp, esp
  002d3	51		 push	 ecx

; 115  : 	struct CharIntNode * tmp = CreateEmptyCharIntNode();

  002d4	e8 00 00 00 00	 call	 _CreateEmptyCharIntNode
  002d9	89 45 fc	 mov	 DWORD PTR _tmp$[ebp], eax

; 116  : 	tmp -> ch = ch;

  002dc	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  002df	8a 4d 08	 mov	 cl, BYTE PTR _ch$[ebp]
  002e2	88 08		 mov	 BYTE PTR [eax], cl

; 117  : 	tmp -> f = 1;

  002e4	8b 55 fc	 mov	 edx, DWORD PTR _tmp$[ebp]
  002e7	c7 42 04 01 00
	00 00		 mov	 DWORD PTR [edx+4], 1

; 118  : 	tmp -> next = head;

  002ee	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  002f1	8b 4d 0c	 mov	 ecx, DWORD PTR _head$[ebp]
  002f4	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 119  : 	head = tmp;

  002f7	8b 55 fc	 mov	 edx, DWORD PTR _tmp$[ebp]
  002fa	89 55 0c	 mov	 DWORD PTR _head$[ebp], edx

; 120  : 	return head;

  002fd	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]

; 121  : }

  00300	8b e5		 mov	 esp, ebp
  00302	5d		 pop	 ebp
  00303	c3		 ret	 0
_Insert	ENDP
; Function compile flags: /Odtp
_curr$ = -4						; size = 4
_ch$ = 8						; size = 1
_head$ = 12						; size = 4
_BumpFrequency PROC

; 124  : {

  00310	55		 push	 ebp
  00311	8b ec		 mov	 ebp, esp
  00313	51		 push	 ecx

; 125  : 	struct CharIntNode * curr = head;

  00314	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  00317	89 45 fc	 mov	 DWORD PTR _curr$[ebp], eax

; 126  : 	if(curr == NULL){

  0031a	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  0031e	75 02		 jne	 SHORT $LN3@BumpFreque

; 127  : 		return;

  00320	eb 30		 jmp	 SHORT $LN5@BumpFreque
$LN3@BumpFreque:

; 128  : 	}
; 129  : 	while(curr != NULL){

  00322	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  00326	74 2a		 je	 SHORT $LN5@BumpFreque

; 130  : 		if(curr -> ch == ch) {

  00328	8b 4d fc	 mov	 ecx, DWORD PTR _curr$[ebp]
  0032b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0032e	0f be 45 08	 movsx	 eax, BYTE PTR _ch$[ebp]
  00332	3b d0		 cmp	 edx, eax
  00334	75 11		 jne	 SHORT $LN1@BumpFreque

; 131  : 			curr -> f = curr -> f + 1;

  00336	8b 4d fc	 mov	 ecx, DWORD PTR _curr$[ebp]
  00339	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0033c	83 c2 01	 add	 edx, 1
  0033f	8b 45 fc	 mov	 eax, DWORD PTR _curr$[ebp]
  00342	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 132  : 			return;

  00345	eb 0b		 jmp	 SHORT $LN5@BumpFreque
$LN1@BumpFreque:

; 133  : 		}
; 134  : 		curr = curr -> next;

  00347	8b 4d fc	 mov	 ecx, DWORD PTR _curr$[ebp]
  0034a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0034d	89 55 fc	 mov	 DWORD PTR _curr$[ebp], edx

; 135  : 	}

  00350	eb d0		 jmp	 SHORT $LN3@BumpFreque
$LN5@BumpFreque:

; 136  : }

  00352	8b e5		 mov	 esp, ebp
  00354	5d		 pop	 ebp
  00355	c3		 ret	 0
_BumpFrequency ENDP
_TEXT	ENDS
PUBLIC	_main
EXTRN	_free:PROC
; Function compile flags: /Odtp
; File d:\source\blog posts\libraries\c\testcharfrequncy.c
_TEXT	SEGMENT
_cf$ = -4						; size = 4
_main	PROC

; 4    : {

  00360	55		 push	 ebp
  00361	8b ec		 mov	 ebp, esp
  00363	51		 push	 ecx

; 5    : 	struct CharFrequency * cf = SetupCharFrequency("Abc");

  00364	68 00 00 00 00	 push	 OFFSET $SG4052
  00369	e8 00 00 00 00	 call	 _SetupCharFrequency
  0036e	83 c4 04	 add	 esp, 4
  00371	89 45 fc	 mov	 DWORD PTR _cf$[ebp], eax

; 6    : 	printf("\nTesting in 'Abc'.\n");

  00374	68 00 00 00 00	 push	 OFFSET $SG4053
  00379	e8 00 00 00 00	 call	 _printf
  0037e	83 c4 04	 add	 esp, 4

; 7    : 	printf("\nFrequency of 'A': %i\n", cf->GetFrequency('A', cf));

  00381	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  00384	50		 push	 eax
  00385	6a 41		 push	 65			; 00000041H
  00387	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  0038a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0038d	ff d2		 call	 edx
  0038f	83 c4 08	 add	 esp, 8
  00392	50		 push	 eax
  00393	68 00 00 00 00	 push	 OFFSET $SG4054
  00398	e8 00 00 00 00	 call	 _printf
  0039d	83 c4 08	 add	 esp, 8

; 8    : 	printf("\nFrequency of 'b': %i\n", cf->GetFrequency('b', cf));

  003a0	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  003a3	50		 push	 eax
  003a4	6a 62		 push	 98			; 00000062H
  003a6	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  003a9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003ac	ff d2		 call	 edx
  003ae	83 c4 08	 add	 esp, 8
  003b1	50		 push	 eax
  003b2	68 00 00 00 00	 push	 OFFSET $SG4055
  003b7	e8 00 00 00 00	 call	 _printf
  003bc	83 c4 08	 add	 esp, 8

; 9    : 	printf("\nFrequency of 'c': %i\n", cf->GetFrequency('c', cf));

  003bf	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  003c2	50		 push	 eax
  003c3	6a 63		 push	 99			; 00000063H
  003c5	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  003c8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003cb	ff d2		 call	 edx
  003cd	83 c4 08	 add	 esp, 8
  003d0	50		 push	 eax
  003d1	68 00 00 00 00	 push	 OFFSET $SG4056
  003d6	e8 00 00 00 00	 call	 _printf
  003db	83 c4 08	 add	 esp, 8

; 10   : 	printf("\nFrequency of 'd': %i\n", cf->GetFrequency('d', cf));

  003de	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  003e1	50		 push	 eax
  003e2	6a 64		 push	 100			; 00000064H
  003e4	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  003e7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003ea	ff d2		 call	 edx
  003ec	83 c4 08	 add	 esp, 8
  003ef	50		 push	 eax
  003f0	68 00 00 00 00	 push	 OFFSET $SG4057
  003f5	e8 00 00 00 00	 call	 _printf
  003fa	83 c4 08	 add	 esp, 8

; 11   : 	cf->PrintFrequencyList(cf);

  003fd	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  00400	50		 push	 eax
  00401	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00404	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00407	ff d2		 call	 edx
  00409	83 c4 04	 add	 esp, 4

; 12   : 	cf->PrintFrequencyMap(cf);

  0040c	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  0040f	50		 push	 eax
  00410	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00413	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00416	ff d2		 call	 edx
  00418	83 c4 04	 add	 esp, 4

; 13   : 	free(cf);

  0041b	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  0041e	50		 push	 eax
  0041f	e8 00 00 00 00	 call	 _free
  00424	83 c4 04	 add	 esp, 4

; 14   : 	cf = SetupCharFrequency("AbcAAbd");

  00427	68 00 00 00 00	 push	 OFFSET $SG4058
  0042c	e8 00 00 00 00	 call	 _SetupCharFrequency
  00431	83 c4 04	 add	 esp, 4
  00434	89 45 fc	 mov	 DWORD PTR _cf$[ebp], eax

; 15   : 	printf("\nTesting in 'AbcAAbd'.\n");

  00437	68 00 00 00 00	 push	 OFFSET $SG4059
  0043c	e8 00 00 00 00	 call	 _printf
  00441	83 c4 04	 add	 esp, 4

; 16   : 	printf("\nFrequency of 'A': %i\n", cf->GetFrequency('A', cf));

  00444	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00447	51		 push	 ecx
  00448	6a 41		 push	 65			; 00000041H
  0044a	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  0044d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00450	ff d0		 call	 eax
  00452	83 c4 08	 add	 esp, 8
  00455	50		 push	 eax
  00456	68 00 00 00 00	 push	 OFFSET $SG4060
  0045b	e8 00 00 00 00	 call	 _printf
  00460	83 c4 08	 add	 esp, 8

; 17   : 	printf("\nFrequency of 'b': %i\n", cf->GetFrequency('b', cf));

  00463	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00466	51		 push	 ecx
  00467	6a 62		 push	 98			; 00000062H
  00469	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  0046c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0046f	ff d0		 call	 eax
  00471	83 c4 08	 add	 esp, 8
  00474	50		 push	 eax
  00475	68 00 00 00 00	 push	 OFFSET $SG4061
  0047a	e8 00 00 00 00	 call	 _printf
  0047f	83 c4 08	 add	 esp, 8

; 18   : 	printf("\nFrequency of 'c': %i\n", cf->GetFrequency('c', cf));

  00482	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00485	51		 push	 ecx
  00486	6a 63		 push	 99			; 00000063H
  00488	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  0048b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0048e	ff d0		 call	 eax
  00490	83 c4 08	 add	 esp, 8
  00493	50		 push	 eax
  00494	68 00 00 00 00	 push	 OFFSET $SG4062
  00499	e8 00 00 00 00	 call	 _printf
  0049e	83 c4 08	 add	 esp, 8

; 19   : 	printf("\nFrequency of 'd': %i\n", cf->GetFrequency('d', cf));

  004a1	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  004a4	51		 push	 ecx
  004a5	6a 64		 push	 100			; 00000064H
  004a7	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  004aa	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  004ad	ff d0		 call	 eax
  004af	83 c4 08	 add	 esp, 8
  004b2	50		 push	 eax
  004b3	68 00 00 00 00	 push	 OFFSET $SG4063
  004b8	e8 00 00 00 00	 call	 _printf
  004bd	83 c4 08	 add	 esp, 8

; 20   : 	cf->PrintFrequencyList(cf);

  004c0	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  004c3	51		 push	 ecx
  004c4	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  004c7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  004ca	ff d0		 call	 eax
  004cc	83 c4 04	 add	 esp, 4

; 21   : 	cf->PrintFrequencyMap(cf);

  004cf	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  004d2	51		 push	 ecx
  004d3	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  004d6	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  004d9	ff d0		 call	 eax
  004db	83 c4 04	 add	 esp, 4

; 22   : 	return 0;

  004de	33 c0		 xor	 eax, eax

; 23   : }

  004e0	8b e5		 mov	 esp, ebp
  004e2	5d		 pop	 ebp
  004e3	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
END
