; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	d:\source\blog posts\libraries\c\TestCharFrequncy.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG3965	DB	0aH, 'Printing frequency list:', 00H
	ORG $+2
$SG3970	DB	0aH, ' %c - %i.', 00H
	ORG $+1
$SG3971	DB	0aH, 00H
	ORG $+2
$SG4029	DB	'Abc', 00H
$SG4030	DB	0aH, 'Testing in ''Abc''.', 0aH, 00H
$SG4031	DB	0aH, 'Frequency of ''A'': %i', 0aH, 00H
	ORG $+1
$SG4032	DB	0aH, 'Frequency of ''b'': %i', 0aH, 00H
	ORG $+1
$SG4033	DB	0aH, 'Frequency of ''c'': %i', 0aH, 00H
	ORG $+1
$SG4034	DB	0aH, 'Frequency of ''d'': %i', 0aH, 00H
	ORG $+1
$SG4035	DB	'AbcAAbd', 00H
$SG4036	DB	0aH, 'Testing in ''AbcAAbd''.', 0aH, 00H
$SG4037	DB	0aH, 'Frequency of ''A'': %i', 0aH, 00H
	ORG $+1
$SG4038	DB	0aH, 'Frequency of ''b'': %i', 0aH, 00H
	ORG $+1
$SG4039	DB	0aH, 'Frequency of ''c'': %i', 0aH, 00H
	ORG $+1
$SG4040	DB	0aH, 'Frequency of ''d'': %i', 0aH, 00H
_DATA	ENDS
PUBLIC	_Contains
; Function compile flags: /Odtp
; File d:\source\blog posts\libraries\c\charfrequency.c
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_ch$ = 8						; size = 1
_cf$ = 12						; size = 4
_Contains PROC

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 16   : 	struct CharIntNode * curr = cf->first;

  00004	8b 45 0c	 mov	 eax, DWORD PTR _cf$[ebp]
  00007	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000a	89 4d fc	 mov	 DWORD PTR _curr$[ebp], ecx

; 17   : 	if(curr == NULL){

  0000d	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  00011	75 04		 jne	 SHORT $LN3@Contains

; 18   : 		return false;

  00013	33 c0		 xor	 eax, eax
  00015	eb 28		 jmp	 SHORT $LN5@Contains
$LN3@Contains:

; 19   : 	}
; 20   : 	while(curr != NULL){

  00017	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  0001b	74 20		 je	 SHORT $LN2@Contains

; 21   : 		if(curr -> ch == ch)

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _curr$[ebp]
  00020	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00023	0f be 4d 08	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00027	3b c1		 cmp	 eax, ecx
  00029	75 07		 jne	 SHORT $LN1@Contains

; 22   : 			return true;

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	eb 0d		 jmp	 SHORT $LN5@Contains
$LN1@Contains:

; 23   : 		curr = curr -> next;

  00032	8b 55 fc	 mov	 edx, DWORD PTR _curr$[ebp]
  00035	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00038	89 45 fc	 mov	 DWORD PTR _curr$[ebp], eax

; 24   : 	}

  0003b	eb da		 jmp	 SHORT $LN3@Contains
$LN2@Contains:

; 25   : 	return false;

  0003d	33 c0		 xor	 eax, eax
$LN5@Contains:

; 26   : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_Contains ENDP
_TEXT	ENDS
PUBLIC	_GetFrequency
; Function compile flags: /Odtp
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_ch$ = 8						; size = 1
_cf$ = 12						; size = 4
_GetFrequency PROC

; 29   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	51		 push	 ecx

; 30   : 	struct CharIntNode * curr = cf->first;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _cf$[ebp]
  00057	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0005a	89 4d fc	 mov	 DWORD PTR _curr$[ebp], ecx

; 31   : 	if(curr == NULL){

  0005d	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  00061	75 04		 jne	 SHORT $LN3@GetFrequen

; 32   : 		return 0;

  00063	33 c0		 xor	 eax, eax
  00065	eb 29		 jmp	 SHORT $LN5@GetFrequen
$LN3@GetFrequen:

; 33   : 	} 
; 34   : 	while(curr != NULL){

  00067	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  0006b	74 21		 je	 SHORT $LN2@GetFrequen

; 35   : 		if(curr -> ch == ch)

  0006d	8b 55 fc	 mov	 edx, DWORD PTR _curr$[ebp]
  00070	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00073	0f be 4d 08	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00077	3b c1		 cmp	 eax, ecx
  00079	75 08		 jne	 SHORT $LN1@GetFrequen

; 36   : 			return curr -> f;

  0007b	8b 55 fc	 mov	 edx, DWORD PTR _curr$[ebp]
  0007e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00081	eb 0d		 jmp	 SHORT $LN5@GetFrequen
$LN1@GetFrequen:

; 37   : 		curr = curr -> next;

  00083	8b 45 fc	 mov	 eax, DWORD PTR _curr$[ebp]
  00086	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00089	89 4d fc	 mov	 DWORD PTR _curr$[ebp], ecx

; 38   : 	}

  0008c	eb d9		 jmp	 SHORT $LN3@GetFrequen
$LN2@GetFrequen:

; 39   : 	return 0;

  0008e	33 c0		 xor	 eax, eax
$LN5@GetFrequen:

; 40   : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_GetFrequency ENDP
_TEXT	ENDS
PUBLIC	_PrintFrequencyList
EXTRN	_printf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_cf$ = 8						; size = 4
_PrintFrequencyList PROC

; 43   : {

  000a0	55		 push	 ebp
  000a1	8b ec		 mov	 ebp, esp
  000a3	51		 push	 ecx

; 44   : 	struct CharIntNode * curr = cf->first;

  000a4	8b 45 08	 mov	 eax, DWORD PTR _cf$[ebp]
  000a7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000aa	89 4d fc	 mov	 DWORD PTR _curr$[ebp], ecx

; 45   : 	printf("\nPrinting frequency list:");

  000ad	68 00 00 00 00	 push	 OFFSET $SG3965
  000b2	e8 00 00 00 00	 call	 _printf
  000b7	83 c4 04	 add	 esp, 4
$LN2@PrintFrequ:

; 46   : 	while(curr != NULL){

  000ba	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  000be	74 26		 je	 SHORT $LN1@PrintFrequ

; 47   : 		printf("\n %c - %i.", curr->ch, curr->f);

  000c0	8b 55 fc	 mov	 edx, DWORD PTR _curr$[ebp]
  000c3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c6	50		 push	 eax
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _curr$[ebp]
  000ca	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000cd	52		 push	 edx
  000ce	68 00 00 00 00	 push	 OFFSET $SG3970
  000d3	e8 00 00 00 00	 call	 _printf
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 48   : 		curr = curr->next;

  000db	8b 45 fc	 mov	 eax, DWORD PTR _curr$[ebp]
  000de	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e1	89 4d fc	 mov	 DWORD PTR _curr$[ebp], ecx

; 49   : 	}

  000e4	eb d4		 jmp	 SHORT $LN2@PrintFrequ
$LN1@PrintFrequ:

; 50   : 	printf("\n");

  000e6	68 00 00 00 00	 push	 OFFSET $SG3971
  000eb	e8 00 00 00 00	 call	 _printf
  000f0	83 c4 04	 add	 esp, 4

; 51   : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_PrintFrequencyList ENDP
_TEXT	ENDS
PUBLIC	_BumpFrequency
PUBLIC	_Insert
PUBLIC	_Initialize
; Function compile flags: /Odtp
_TEXT	SEGMENT
_input$ = 8						; size = 4
_cf$ = 12						; size = 4
_Initialize PROC

; 53   : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp

; 54   : 	if(cf == NULL) return;

  00103	83 7d 0c 00	 cmp	 DWORD PTR _cf$[ebp], 0
  00107	75 02		 jne	 SHORT $LN6@Initialize
  00109	eb 6a		 jmp	 SHORT $LN7@Initialize
$LN6@Initialize:

; 55   : 	if(input == NULL) return;

  0010b	83 7d 08 00	 cmp	 DWORD PTR _input$[ebp], 0
  0010f	75 02		 jne	 SHORT $LN4@Initialize
  00111	eb 62		 jmp	 SHORT $LN7@Initialize
$LN4@Initialize:

; 56   : 	while(*input){

  00113	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00116	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00119	85 c9		 test	 ecx, ecx
  0011b	74 58		 je	 SHORT $LN7@Initialize

; 57   : 		if(!(cf->Contains(*input, cf))){

  0011d	8b 55 0c	 mov	 edx, DWORD PTR _cf$[ebp]
  00120	52		 push	 edx
  00121	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00124	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00127	51		 push	 ecx
  00128	8b 55 0c	 mov	 edx, DWORD PTR _cf$[ebp]
  0012b	8b 02		 mov	 eax, DWORD PTR [edx]
  0012d	ff d0		 call	 eax
  0012f	83 c4 08	 add	 esp, 8
  00132	85 c0		 test	 eax, eax
  00134	75 1e		 jne	 SHORT $LN2@Initialize

; 58   : 			cf->first = Insert(*input, cf->first);

  00136	8b 4d 0c	 mov	 ecx, DWORD PTR _cf$[ebp]
  00139	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0013c	52		 push	 edx
  0013d	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00140	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 _Insert
  00149	83 c4 08	 add	 esp, 8
  0014c	8b 55 0c	 mov	 edx, DWORD PTR _cf$[ebp]
  0014f	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 59   : 		}
; 60   : 		else {

  00152	eb 16		 jmp	 SHORT $LN1@Initialize
$LN2@Initialize:

; 61   : 			BumpFrequency(*input, cf->first);

  00154	8b 45 0c	 mov	 eax, DWORD PTR _cf$[ebp]
  00157	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0015a	51		 push	 ecx
  0015b	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0015e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 _BumpFrequency
  00167	83 c4 08	 add	 esp, 8
$LN1@Initialize:

; 62   : 		}
; 63   : 		input++;

  0016a	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d 08	 mov	 DWORD PTR _input$[ebp], ecx

; 64   : 	}

  00173	eb 9e		 jmp	 SHORT $LN4@Initialize
$LN7@Initialize:

; 65   : }

  00175	5d		 pop	 ebp
  00176	c3		 ret	 0
_Initialize ENDP
_TEXT	ENDS
PUBLIC	_CreateEmptyCharFrequency
PUBLIC	_SetupCharFrequency
; Function compile flags: /Odtp
_TEXT	SEGMENT
_cf$ = -4						; size = 4
_input$ = 8						; size = 4
_SetupCharFrequency PROC

; 68   : {

  00180	55		 push	 ebp
  00181	8b ec		 mov	 ebp, esp
  00183	51		 push	 ecx

; 69   : 	struct CharFrequency * cf = CreateEmptyCharFrequency();

  00184	e8 00 00 00 00	 call	 _CreateEmptyCharFrequency
  00189	89 45 fc	 mov	 DWORD PTR _cf$[ebp], eax

; 70   : 	cf->Contains = Contains;

  0018c	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  0018f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _Contains

; 71   : 	cf->GetFrequency = GetFrequency;

  00195	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00198	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET _GetFrequency

; 72   : 	cf->PrintFrequencyList = PrintFrequencyList;

  0019f	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  001a2	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET _PrintFrequencyList

; 73   : 	cf->first = NULL;

  001a9	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  001ac	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 74   : 	Initialize(input, cf);

  001b3	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  001b6	51		 push	 ecx
  001b7	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  001ba	52		 push	 edx
  001bb	e8 00 00 00 00	 call	 _Initialize
  001c0	83 c4 08	 add	 esp, 8

; 75   : 	return cf;

  001c3	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]

; 76   : }

  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c3		 ret	 0
_SetupCharFrequency ENDP
_TEXT	ENDS
EXTRN	_malloc:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_cf$ = -4						; size = 4
_CreateEmptyCharFrequency PROC

; 79   : {

  001d0	55		 push	 ebp
  001d1	8b ec		 mov	 ebp, esp
  001d3	51		 push	 ecx

; 80   : 	struct CharFrequency * cf = (struct CharFrequency *)malloc(sizeof(struct CharFrequency));

  001d4	6a 10		 push	 16			; 00000010H
  001d6	e8 00 00 00 00	 call	 _malloc
  001db	83 c4 04	 add	 esp, 4
  001de	89 45 fc	 mov	 DWORD PTR _cf$[ebp], eax

; 81   : 	if(cf == NULL){

  001e1	83 7d fc 00	 cmp	 DWORD PTR _cf$[ebp], 0
  001e5	75 0d		 jne	 SHORT $LN1@CreateEmpt

; 82   : 		cf = (struct CharFrequency *)malloc(sizeof(struct CharFrequency));

  001e7	6a 10		 push	 16			; 00000010H
  001e9	e8 00 00 00 00	 call	 _malloc
  001ee	83 c4 04	 add	 esp, 4
  001f1	89 45 fc	 mov	 DWORD PTR _cf$[ebp], eax
$LN1@CreateEmpt:

; 83   : 	}
; 84   : 	return cf;

  001f4	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]

; 85   : }

  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c3		 ret	 0
_CreateEmptyCharFrequency ENDP
_TEXT	ENDS
PUBLIC	_CreateEmptyCharIntNode
; Function compile flags: /Odtp
_TEXT	SEGMENT
_cin$ = -4						; size = 4
_CreateEmptyCharIntNode PROC

; 88   : {

  00200	55		 push	 ebp
  00201	8b ec		 mov	 ebp, esp
  00203	51		 push	 ecx

; 89   : 	struct CharIntNode * cin = (struct CharIntNode *)malloc(sizeof(struct CharIntNode *));

  00204	6a 04		 push	 4
  00206	e8 00 00 00 00	 call	 _malloc
  0020b	83 c4 04	 add	 esp, 4
  0020e	89 45 fc	 mov	 DWORD PTR _cin$[ebp], eax

; 90   : 	if(cin == NULL){

  00211	83 7d fc 00	 cmp	 DWORD PTR _cin$[ebp], 0
  00215	75 0d		 jne	 SHORT $LN1@CreateEmpt@2

; 91   : 		cin = (struct CharIntNode *)malloc(sizeof(struct CharIntNode *));

  00217	6a 04		 push	 4
  00219	e8 00 00 00 00	 call	 _malloc
  0021e	83 c4 04	 add	 esp, 4
  00221	89 45 fc	 mov	 DWORD PTR _cin$[ebp], eax
$LN1@CreateEmpt@2:

; 92   : 	}
; 93   : 	return cin;

  00224	8b 45 fc	 mov	 eax, DWORD PTR _cin$[ebp]

; 94   : }

  00227	8b e5		 mov	 esp, ebp
  00229	5d		 pop	 ebp
  0022a	c3		 ret	 0
_CreateEmptyCharIntNode ENDP
; Function compile flags: /Odtp
_tmp$ = -4						; size = 4
_ch$ = 8						; size = 1
_head$ = 12						; size = 4
_Insert	PROC

; 97   : {

  00230	55		 push	 ebp
  00231	8b ec		 mov	 ebp, esp
  00233	51		 push	 ecx

; 98   : 	struct CharIntNode * tmp = CreateEmptyCharIntNode();

  00234	e8 00 00 00 00	 call	 _CreateEmptyCharIntNode
  00239	89 45 fc	 mov	 DWORD PTR _tmp$[ebp], eax

; 99   : 	tmp -> ch = ch;

  0023c	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  0023f	8a 4d 08	 mov	 cl, BYTE PTR _ch$[ebp]
  00242	88 08		 mov	 BYTE PTR [eax], cl

; 100  : 	tmp -> f = 1;

  00244	8b 55 fc	 mov	 edx, DWORD PTR _tmp$[ebp]
  00247	c7 42 04 01 00
	00 00		 mov	 DWORD PTR [edx+4], 1

; 101  : 	tmp -> next = head;

  0024e	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  00251	8b 4d 0c	 mov	 ecx, DWORD PTR _head$[ebp]
  00254	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 102  : 	head = tmp;

  00257	8b 55 fc	 mov	 edx, DWORD PTR _tmp$[ebp]
  0025a	89 55 0c	 mov	 DWORD PTR _head$[ebp], edx

; 103  : 	return head;

  0025d	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]

; 104  : }

  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
_Insert	ENDP
; Function compile flags: /Odtp
_curr$ = -4						; size = 4
_ch$ = 8						; size = 1
_head$ = 12						; size = 4
_BumpFrequency PROC

; 107  : {

  00270	55		 push	 ebp
  00271	8b ec		 mov	 ebp, esp
  00273	51		 push	 ecx

; 108  : 	struct CharIntNode * curr = head;

  00274	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  00277	89 45 fc	 mov	 DWORD PTR _curr$[ebp], eax

; 109  : 	if(curr == NULL){

  0027a	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  0027e	75 02		 jne	 SHORT $LN3@BumpFreque

; 110  : 		return;

  00280	eb 30		 jmp	 SHORT $LN5@BumpFreque
$LN3@BumpFreque:

; 111  : 	}
; 112  : 	while(curr != NULL){

  00282	83 7d fc 00	 cmp	 DWORD PTR _curr$[ebp], 0
  00286	74 2a		 je	 SHORT $LN5@BumpFreque

; 113  : 		if(curr -> ch == ch) {

  00288	8b 4d fc	 mov	 ecx, DWORD PTR _curr$[ebp]
  0028b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0028e	0f be 45 08	 movsx	 eax, BYTE PTR _ch$[ebp]
  00292	3b d0		 cmp	 edx, eax
  00294	75 11		 jne	 SHORT $LN1@BumpFreque

; 114  : 			curr -> f = curr -> f + 1;

  00296	8b 4d fc	 mov	 ecx, DWORD PTR _curr$[ebp]
  00299	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0029c	83 c2 01	 add	 edx, 1
  0029f	8b 45 fc	 mov	 eax, DWORD PTR _curr$[ebp]
  002a2	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 115  : 			return;

  002a5	eb 0b		 jmp	 SHORT $LN5@BumpFreque
$LN1@BumpFreque:

; 116  : 		}
; 117  : 		curr = curr -> next;

  002a7	8b 4d fc	 mov	 ecx, DWORD PTR _curr$[ebp]
  002aa	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002ad	89 55 fc	 mov	 DWORD PTR _curr$[ebp], edx

; 118  : 	}

  002b0	eb d0		 jmp	 SHORT $LN3@BumpFreque
$LN5@BumpFreque:

; 119  : }

  002b2	8b e5		 mov	 esp, ebp
  002b4	5d		 pop	 ebp
  002b5	c3		 ret	 0
_BumpFrequency ENDP
_TEXT	ENDS
PUBLIC	_main
EXTRN	_free:PROC
; Function compile flags: /Odtp
; File d:\source\blog posts\libraries\c\testcharfrequncy.c
_TEXT	SEGMENT
_cf$ = -4						; size = 4
_main	PROC

; 4    : {

  002c0	55		 push	 ebp
  002c1	8b ec		 mov	 ebp, esp
  002c3	51		 push	 ecx

; 5    : 	struct CharFrequency * cf = SetupCharFrequency("Abc");

  002c4	68 00 00 00 00	 push	 OFFSET $SG4029
  002c9	e8 00 00 00 00	 call	 _SetupCharFrequency
  002ce	83 c4 04	 add	 esp, 4
  002d1	89 45 fc	 mov	 DWORD PTR _cf$[ebp], eax

; 6    : 	printf("\nTesting in 'Abc'.\n");

  002d4	68 00 00 00 00	 push	 OFFSET $SG4030
  002d9	e8 00 00 00 00	 call	 _printf
  002de	83 c4 04	 add	 esp, 4

; 7    : 	printf("\nFrequency of 'A': %i\n", cf->GetFrequency('A', cf));

  002e1	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  002e4	50		 push	 eax
  002e5	6a 41		 push	 65			; 00000041H
  002e7	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  002ea	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002ed	ff d2		 call	 edx
  002ef	83 c4 08	 add	 esp, 8
  002f2	50		 push	 eax
  002f3	68 00 00 00 00	 push	 OFFSET $SG4031
  002f8	e8 00 00 00 00	 call	 _printf
  002fd	83 c4 08	 add	 esp, 8

; 8    : 	printf("\nFrequency of 'b': %i\n", cf->GetFrequency('b', cf));

  00300	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  00303	50		 push	 eax
  00304	6a 62		 push	 98			; 00000062H
  00306	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00309	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0030c	ff d2		 call	 edx
  0030e	83 c4 08	 add	 esp, 8
  00311	50		 push	 eax
  00312	68 00 00 00 00	 push	 OFFSET $SG4032
  00317	e8 00 00 00 00	 call	 _printf
  0031c	83 c4 08	 add	 esp, 8

; 9    : 	printf("\nFrequency of 'c': %i\n", cf->GetFrequency('c', cf));

  0031f	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  00322	50		 push	 eax
  00323	6a 63		 push	 99			; 00000063H
  00325	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00328	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0032b	ff d2		 call	 edx
  0032d	83 c4 08	 add	 esp, 8
  00330	50		 push	 eax
  00331	68 00 00 00 00	 push	 OFFSET $SG4033
  00336	e8 00 00 00 00	 call	 _printf
  0033b	83 c4 08	 add	 esp, 8

; 10   : 	printf("\nFrequency of 'd': %i\n", cf->GetFrequency('d', cf));

  0033e	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  00341	50		 push	 eax
  00342	6a 64		 push	 100			; 00000064H
  00344	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00347	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0034a	ff d2		 call	 edx
  0034c	83 c4 08	 add	 esp, 8
  0034f	50		 push	 eax
  00350	68 00 00 00 00	 push	 OFFSET $SG4034
  00355	e8 00 00 00 00	 call	 _printf
  0035a	83 c4 08	 add	 esp, 8

; 11   : 	cf->PrintFrequencyList(cf);

  0035d	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  00360	50		 push	 eax
  00361	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00364	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00367	ff d2		 call	 edx
  00369	83 c4 04	 add	 esp, 4

; 12   : 	free(cf);

  0036c	8b 45 fc	 mov	 eax, DWORD PTR _cf$[ebp]
  0036f	50		 push	 eax
  00370	e8 00 00 00 00	 call	 _free
  00375	83 c4 04	 add	 esp, 4

; 13   : 	cf = SetupCharFrequency("AbcAAbd");

  00378	68 00 00 00 00	 push	 OFFSET $SG4035
  0037d	e8 00 00 00 00	 call	 _SetupCharFrequency
  00382	83 c4 04	 add	 esp, 4
  00385	89 45 fc	 mov	 DWORD PTR _cf$[ebp], eax

; 14   : 	printf("\nTesting in 'AbcAAbd'.\n");

  00388	68 00 00 00 00	 push	 OFFSET $SG4036
  0038d	e8 00 00 00 00	 call	 _printf
  00392	83 c4 04	 add	 esp, 4

; 15   : 	printf("\nFrequency of 'A': %i\n", cf->GetFrequency('A', cf));

  00395	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00398	51		 push	 ecx
  00399	6a 41		 push	 65			; 00000041H
  0039b	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  0039e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003a1	ff d0		 call	 eax
  003a3	83 c4 08	 add	 esp, 8
  003a6	50		 push	 eax
  003a7	68 00 00 00 00	 push	 OFFSET $SG4037
  003ac	e8 00 00 00 00	 call	 _printf
  003b1	83 c4 08	 add	 esp, 8

; 16   : 	printf("\nFrequency of 'b': %i\n", cf->GetFrequency('b', cf));

  003b4	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  003b7	51		 push	 ecx
  003b8	6a 62		 push	 98			; 00000062H
  003ba	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  003bd	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003c0	ff d0		 call	 eax
  003c2	83 c4 08	 add	 esp, 8
  003c5	50		 push	 eax
  003c6	68 00 00 00 00	 push	 OFFSET $SG4038
  003cb	e8 00 00 00 00	 call	 _printf
  003d0	83 c4 08	 add	 esp, 8

; 17   : 	printf("\nFrequency of 'c': %i\n", cf->GetFrequency('c', cf));

  003d3	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  003d6	51		 push	 ecx
  003d7	6a 63		 push	 99			; 00000063H
  003d9	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  003dc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003df	ff d0		 call	 eax
  003e1	83 c4 08	 add	 esp, 8
  003e4	50		 push	 eax
  003e5	68 00 00 00 00	 push	 OFFSET $SG4039
  003ea	e8 00 00 00 00	 call	 _printf
  003ef	83 c4 08	 add	 esp, 8

; 18   : 	printf("\nFrequency of 'd': %i\n", cf->GetFrequency('d', cf));

  003f2	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  003f5	51		 push	 ecx
  003f6	6a 64		 push	 100			; 00000064H
  003f8	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  003fb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003fe	ff d0		 call	 eax
  00400	83 c4 08	 add	 esp, 8
  00403	50		 push	 eax
  00404	68 00 00 00 00	 push	 OFFSET $SG4040
  00409	e8 00 00 00 00	 call	 _printf
  0040e	83 c4 08	 add	 esp, 8

; 19   : 	cf->PrintFrequencyList(cf);

  00411	8b 4d fc	 mov	 ecx, DWORD PTR _cf$[ebp]
  00414	51		 push	 ecx
  00415	8b 55 fc	 mov	 edx, DWORD PTR _cf$[ebp]
  00418	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0041b	ff d0		 call	 eax
  0041d	83 c4 04	 add	 esp, 4

; 20   : 	return 0;

  00420	33 c0		 xor	 eax, eax

; 21   : }

  00422	8b e5		 mov	 esp, ebp
  00424	5d		 pop	 ebp
  00425	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
END
